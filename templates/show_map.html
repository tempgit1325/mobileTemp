<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="initial-scale=1, width=device-width">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
        crossorigin=""/>
    <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.css" />
    <link rel="stylesheet" href="{{ url_for('static', filename='css/index.css') }}">
    <title>show_map</title>
</head>
<body>
<a href="{{ url_for('show_views.logout') }}">logout</a><br>
<p>map</p>
<button id="enableNotif">WÅ‚Ä…cz powiadomienia</button>

<a href="https://www.google.com/maps/dir/{{shipment.pickup_lat}},{{shipment.pickup_lng}}/{{ shipment.delivery_lat}},{{ shipment.delivery_lng}}">GoogleMaps</a><br>

<div id="map"
    data-pickup-lat="{{ shipment.pickup_lat or 0 }}" 
    data-pickup-lng="{{ shipment.pickup_lng or 0 }}"
    data-delivery-lat="{{ shipment.delivery_lat or 0 }}" 
    data-delivery-lng="{{ shipment.delivery_lng or 0 }}" 
    style="height: 500px;"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""></script>

<script src="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.js"></script>

<script>
var mapDiv = document.getElementById('map');

let notified = false;
let GEOFENCE_RADIUS_METERS = 250; 

// Tworzymy oryginalny obiekt shipment
const shipmentData = {
    pickup_lat: parseFloat(mapDiv.dataset.pickupLat),
    pickup_lng: parseFloat(mapDiv.dataset.pickupLng),
    delivery_lat: parseFloat(mapDiv.dataset.deliveryLat),
    delivery_lng: parseFloat(mapDiv.dataset.deliveryLng)
};

// ðŸ”¹ Proxy, ktÃ³re reaguje na kaÅ¼dÄ… zmianÄ™ w shipment
window.shipment = new Proxy(shipmentData, {
    set(target, prop, value) {
        target[prop] = value;
        console.log(`shipment.${prop} zmienione na ${value}`);
        // Automatycznie odÅ›wieÅ¼amy trasÄ™ po zmianie wspÃ³Å‚rzÄ™dnych
        refreshMap();
        return true;
    }
});

function getPickupLatLng() {
    return L.latLng(shipment.pickup_lat, shipment.pickup_lng);
}

function getDeliveryLatLng() {
    return L.latLng(shipment.delivery_lat, shipment.delivery_lng);
}

// Inicjalizacja mapy
var map = L.map('map').setView(getPickupLatLng(), 13);

L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19 }).addTo(map);

// Routing
window.routing = L.Routing.control({
    waypoints: [
        getPickupLatLng(),
        getDeliveryLatLng()
    ],
    createMarker: function(i, waypoint, n){
        if (i === 0) return L.marker(waypoint.latLng).bindPopup("Pickup location");
        if (i === 1) return L.marker(waypoint.latLng).bindPopup("Delivery location");
        return null;
    }
}).addTo(map);

// Geofence
function checkGeofence(userLatLng, destinationLatLng, radiusMeters) {
    const distance = userLatLng.distanceTo(destinationLatLng);
    if (distance <= radiusMeters) {
        console.log("W strefie geofence");
        return true;
    }
    return false;
}

// Aktualizacja trasy
function updateRoute() {
    if (!window.routing) return;
    window.routing.setWaypoints([
        getPickupLatLng(),
        getDeliveryLatLng()
    ]);
}

// OdÅ›wieÅ¼anie mapy i dystansu
function refreshMap(userLat, userLng) {
    const userLatLng = userLat && userLng ? L.latLng(userLat, userLng) : map.getCenter();
    const deliveryLatLng = getDeliveryLatLng();

    updateRoute();

    const insideGeofence = checkGeofence(userLatLng, deliveryLatLng, GEOFENCE_RADIUS_METERS);

    console.log("Dystans do celu:", userLatLng.distanceTo(deliveryLatLng), "m");

    if (insideGeofence && !notified) {
        notified = true;
        alert("JesteÅ› blisko celu!");
    }
}

// Geolokalizacja uÅ¼ytkownika
navigator.geolocation.watchPosition(
    pos => {
        const userLatLng = L.latLng(pos.coords.latitude, pos.coords.longitude);
        const deliveryLatLng = getDeliveryLatLng();
        const insideGeofence = checkGeofence(userLatLng, deliveryLatLng, GEOFENCE_RADIUS_METERS);

        console.log("Dystans do celu:", userLatLng.distanceTo(deliveryLatLng), "m");

        if (insideGeofence && !notified) {
            notified = true;
            alert("JesteÅ› blisko celu!");
        }
    },
    err => console.error(err),
    { enableHighAccuracy: true }
);

// Funkcja do rÄ™cznej symulacji pozycji w konsoli
window.simulatePosition = function(lat, lng) {
    refreshMap(lat, lng);
};
</script>

</body>
</html>
